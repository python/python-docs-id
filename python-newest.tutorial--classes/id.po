# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# oon arfiandwi <oon.arfiandwi@gmail.com>, 2019
# Ryan Febriansyah <15523163@students.uii.ac.id>, 2020
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-08-20 03:54+0000\n"
"PO-Revision-Date: 2017-02-16 23:39+0000\n"
"Last-Translator: Ryan Febriansyah <15523163@students.uii.ac.id>, 2020\n"
"Language-Team: Indonesian (https://www.transifex.com/python-doc/teams/5390/id/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: id\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../tutorial/classes.rst:5
msgid "Classes"
msgstr "Classes"

#: ../../tutorial/classes.rst:7
msgid ""
"Classes provide a means of bundling data and functionality together.  "
"Creating a new class creates a new *type* of object, allowing new "
"*instances* of that type to be made.  Each class instance can have "
"attributes attached to it for maintaining its state.  Class instances can "
"also have methods (defined by its class) for modifying its state."
msgstr ""
"*Classes* atau kelas-kelas menyediakan sarana untuk menggabungkan data dan "
"fungsionalitas bersama. Membuat sebuah *class* baru menghasilkan objek "
"dengan *type* baru, memungkinkan dibuat *instance* baru dari tipe itu. "
"Setiap *instance* dari *class* dapat memiliki atribut yang melekat padanya "
"untuk mempertahankan kondisinya. *Instance* dari sebuah *class* juga dapat "
"memiliki metode (ditentukan oleh *class*) untuk memodifikasi kondisinya."

#: ../../tutorial/classes.rst:13
msgid ""
"Compared with other programming languages, Python's class mechanism adds "
"classes with a minimum of new syntax and semantics.  It is a mixture of the "
"class mechanisms found in C++ and Modula-3.  Python classes provide all the "
"standard features of Object Oriented Programming: the class inheritance "
"mechanism allows multiple base classes, a derived class can override any "
"methods of its base class or classes, and a method can call the method of a "
"base class with the same name.  Objects can contain arbitrary amounts and "
"kinds of data.  As is true for modules, classes partake of the dynamic "
"nature of Python: they are created at runtime, and can be modified further "
"after creation."
msgstr ""
"Dibandingkan dengan bahasa pemrograman lain, mekanisme kelas Python menambah"
" kelas dengan minimum sintaksis dan semantik baru. Ini adalah campuran dari "
"mekanisme kelas yang ditemukan dalam C++ dan Modula-3. Kelas Python "
"menyediakan semua fitur standar Pemrograman Berorientasi Objek: mekanisme "
"pewarisan kelas memungkinkan beberapa kelas dasar, kelas turunan dapat "
"menimpa metode apa pun dari kelas dasar atau kelasnya, dan metode dapat "
"memanggil metode kelas dasar dengan nama yang sama . Objek dapat berisi "
"jumlah dan jenis data yang berubah-ubah. Seperti halnya untuk modul, kelas "
"mengambil bagian dari sifat dinamis Python: mereka dibuat pada saat runtime,"
" dan dapat dimodifikasi lebih lanjut setelah pembuatan."

#: ../../tutorial/classes.rst:23
msgid ""
"In C++ terminology, normally class members (including the data members) are "
"*public* (except see below :ref:`tut-private`), and all member functions are"
" *virtual*.  As in Modula-3, there are no shorthands for referencing the "
"object's members from its methods: the method function is declared with an "
"explicit first argument representing the object, which is provided "
"implicitly by the call.  As in Smalltalk, classes themselves are objects.  "
"This provides semantics for importing and renaming.  Unlike C++ and "
"Modula-3, built-in types can be used as base classes for extension by the "
"user.  Also, like in C++, most built-in operators with special syntax "
"(arithmetic operators, subscripting etc.) can be redefined for class "
"instances."
msgstr ""
"Dalam terminologi C++, biasanya anggota kelas (termasuk anggota data) adalah"
" *public* (kecuali lihat di bawah :ref:`tut-private`), dan semua fungsi "
"anggota adalah *virtual*. Seperti dalam Modula-3, tidak ada singkatan untuk "
"merujuk anggota objek dari metodenya: fungsi metode dideklarasikan dengan "
"argumen pertama eksplisit yang mewakili objek, yang diberikan secara "
"implisit oleh panggilan. Seperti dalam Smalltalk, kelas itu sendiri adalah "
"objek. Ini memberikan semantik untuk mengimpor dan mengganti nama. Tidak "
"seperti C++ dan Modula-3, tipe bawaan dapat digunakan sebagai kelas dasar "
"untuk ekstensi oleh pengguna. Juga, seperti di C++, sebagian besar operator "
"bawaan dengan sintaks khusus (operator aritmatika, *subscripting* dll) dapat"
" didefinisikan ulang untuk *instance* kelas."

#: ../../tutorial/classes.rst:34
msgid ""
"(Lacking universally accepted terminology to talk about classes, I will make"
" occasional use of Smalltalk and C++ terms.  I would use Modula-3 terms, "
"since its object-oriented semantics are closer to those of Python than C++, "
"but I expect that few readers have heard of it.)"
msgstr ""
"(Kurangnya terminologi yang diterima secara universal untuk berbicara "
"tentang kelas, saya akan sesekali menggunakan istilah Smalltalk dan C++. "
"Saya akan menggunakan istilah Modula-3, karena semantik berorientasi "
"objeknya lebih dekat dengan Python daripada C++, tapi saya berharap bahwa "
"beberapa pembaca pernah mendengarnya.)"

#: ../../tutorial/classes.rst:43
msgid "A Word About Names and Objects"
msgstr "Sepatah Kata Tentang Nama dan Objek"

#: ../../tutorial/classes.rst:45
msgid ""
"Objects have individuality, and multiple names (in multiple scopes) can be "
"bound to the same object.  This is known as aliasing in other languages.  "
"This is usually not appreciated on a first glance at Python, and can be "
"safely ignored when dealing with immutable basic types (numbers, strings, "
"tuples).  However, aliasing has a possibly surprising effect on the "
"semantics of Python code involving mutable objects such as lists, "
"dictionaries, and most other types. This is usually used to the benefit of "
"the program, since aliases behave like pointers in some respects.  For "
"example, passing an object is cheap since only a pointer is passed by the "
"implementation; and if a function modifies an object passed as an argument, "
"the caller will see the change --- this eliminates the need for two "
"different argument passing mechanisms as in Pascal."
msgstr ""
"Objek memiliki individualitas, dan banyak nama (dalam berbagai lingkup) "
"dapat terikat ke objek yang sama. Ini dikenal sebagai *aliasing* dalam "
"bahasa lain. Ini biasanya tidak dihargai pada pandangan pertama pada Python,"
" dan dapat diabaikan dengan aman ketika berhadapan dengan tipe dasar yang "
"tidak dapat diubah (angka, string, *tuple*). Namun, *aliasing* memiliki efek"
" yang mungkin mengejutkan pada semantik kode Python yang melibatkan objek "
"yang bisa berubah seperti daftar *list*, kamus *dictionary*, dan sebagian "
"besar jenis lainnya. Ini biasanya digunakan untuk kepentingan program, "
"karena alias berperilaku seperti *pointers* dalam beberapa hal. Sebagai "
"contoh, melewatkan objek adalah murah karena hanya sebuah *pointer* "
"dilewatkan oleh implementasi; dan jika suatu fungsi memodifikasi objek yang "
"dilewatkan sebagai argumen, pemanggil akan melihat perubahan --- ini "
"menghilangkan kebutuhan untuk dua mekanisme yang berbeda melewatkan argumen "
"*argument passing* seperti dalam Pascal."

#: ../../tutorial/classes.rst:61
msgid "Python Scopes and Namespaces"
msgstr "Lingkup Python dan *Namespaces*"

#: ../../tutorial/classes.rst:63
msgid ""
"Before introducing classes, I first have to tell you something about "
"Python's scope rules.  Class definitions play some neat tricks with "
"namespaces, and you need to know how scopes and namespaces work to fully "
"understand what's going on. Incidentally, knowledge about this subject is "
"useful for any advanced Python programmer."
msgstr ""
"Sebelum memperkenalkan kelas, pertama-tama saya harus memberi tahu Anda "
"tentang aturan ruang lingkup *scope* Python. Definisi kelas memainkan "
"beberapa trik rapi dengan ruang nama *namespaces*, dan Anda perlu tahu "
"bagaimana ruang lingkup dan ruang nama *namespaces* bekerja untuk sepenuhnya"
" memahami apa yang terjadi. Kebetulan, pengetahuan tentang subjek ini "
"berguna untuk programmer Python tingkat lanjut."

#: ../../tutorial/classes.rst:69
msgid "Let's begin with some definitions."
msgstr "Mari kita mulai dengan beberapa definisi."

#: ../../tutorial/classes.rst:71
msgid ""
"A *namespace* is a mapping from names to objects.  Most namespaces are "
"currently implemented as Python dictionaries, but that's normally not "
"noticeable in any way (except for performance), and it may change in the "
"future.  Examples of namespaces are: the set of built-in names (containing "
"functions such as :func:`abs`, and built-in exception names); the global "
"names in a module; and the local names in a function invocation.  In a sense"
" the set of attributes of an object also form a namespace.  The important "
"thing to know about namespaces is that there is absolutely no relation "
"between names in different namespaces; for instance, two different modules "
"may both define a function ``maximize`` without confusion --- users of the "
"modules must prefix it with the module name."
msgstr ""
"Sebuah *namespace* adalah pemetaan dari nama ke objek. Sebagian besar ruang "
"nama *namespace* saat ini diimplementasikan sebagai kamus *dictionary* "
"Python, tetapi itu biasanya tidak terlihat dengan cara apa pun (kecuali "
"untuk kinerja), dan itu mungkin berubah di masa depan. Contoh ruang nama "
"*namespace* adalah: himpunan nama bawaan (berisi fungsi seperti :func:`abs`,"
" dan nama pengecualian bawaan); nama-nama global dalam sebuah modul; dan "
"nama-nama lokal dalam pemanggilan fungsi. Dalam arti himpunan atribut suatu "
"objek juga membentuk *namespace*. Hal penting yang perlu diketahui tentang "
"ruang nama *namespace* adalah sama sekali tidak ada hubungan antara nama "
"dalam ruang nama *namespace* yang berbeda; misalnya, dua modul yang berbeda "
"dapat mendefinisikan fungsi ``maximize`` tanpa kebingungan --- pengguna "
"modul harus memberikan awalan dengan nama modul."

#: ../../tutorial/classes.rst:82
msgid ""
"By the way, I use the word *attribute* for any name following a dot --- for "
"example, in the expression ``z.real``, ``real`` is an attribute of the "
"object ``z``.  Strictly speaking, references to names in modules are "
"attribute references: in the expression ``modname.funcname``, ``modname`` is"
" a module object and ``funcname`` is an attribute of it.  In this case there"
" happens to be a straightforward mapping between the module's attributes and"
" the global names defined in the module: they share the same namespace!  "
"[#]_"
msgstr ""
"Ngomong-ngomong, saya menggunakan kata *attribute* untuk nama apa pun yang "
"mengikuti titik --- misalnya, dalam ekspresi ``z.real``, ``real`` adalah "
"atribut dari objek ``z`` . Sebenarnya, referensi ke nama dalam modul adalah "
"referensi atribut: dalam ekspresi ``modname.funcname``, ``modname`` adalah "
"objek modul dan ``funcname`` adalah atributnya. Dalam kasus ini akan terjadi"
" pemetaan langsung antara atribut modul dan nama global yang didefinisikan "
"dalam modul: mereka berbagi namespace yang sama! [#]_"

#: ../../tutorial/classes.rst:90
msgid ""
"Attributes may be read-only or writable.  In the latter case, assignment to "
"attributes is possible.  Module attributes are writable: you can write "
"``modname.the_answer = 42``.  Writable attributes may also be deleted with "
"the :keyword:`del` statement.  For example, ``del modname.the_answer`` will "
"remove the attribute :attr:`the_answer` from the object named by "
"``modname``."
msgstr ""
"Atribut dapat baca-saja *read-only* atau dapat ditulis. Dalam kasus "
"terakhir, pemberian nilai ke atribut dimungkinkan. Atribut modul dapat "
"ditulis: Anda dapat menulis ``modname.the_answer = 42``. Atribut yang dapat "
"ditulis juga dapat dihapus dengan pernyataan :keyword:`del`. Sebagai contoh,"
" ``del modname.the_answer`` akan menghapus atribut :attr:`the_answer` dari "
"objek yang dinamai oleh ``modname``."

#: ../../tutorial/classes.rst:96
msgid ""
"Namespaces are created at different moments and have different lifetimes.  "
"The namespace containing the built-in names is created when the Python "
"interpreter starts up, and is never deleted.  The global namespace for a "
"module is created when the module definition is read in; normally, module "
"namespaces also last until the interpreter quits.  The statements executed "
"by the top-level invocation of the interpreter, either read from a script "
"file or interactively, are considered part of a module called "
":mod:`__main__`, so they have their own global namespace.  (The built-in "
"names actually also live in a module; this is called :mod:`builtins`.)"
msgstr ""
"*Namespace* dibuat pada saat yang berbeda dan memiliki masa hidup yang "
"berbeda. *Namespace* yang berisi nama-nama bawaan dibuat ketika interpreter "
"Python dimulai, dan tidak pernah dihapus. *Namespace* global untuk modul "
"dibuat ketika definisi modul dibaca; biasanya, *namespace* modul juga "
"bertahan hingga *interpreter* berhenti. Pernyataan yang dieksekusi oleh "
"pemanggilan *interpreter* tingkat atas, baik membaca dari file skrip atau "
"secara interaktif, dianggap sebagai bagian dari modul yang disebut "
":mod:`__main__`, sehingga mereka memiliki namespace global sendiri. (Nama "
"bawaan sebenarnya juga hidup dalam modul; ini disebut :mod:`builtins`.)"

#: ../../tutorial/classes.rst:106
msgid ""
"The local namespace for a function is created when the function is called, "
"and deleted when the function returns or raises an exception that is not "
"handled within the function.  (Actually, forgetting would be a better way to"
" describe what actually happens.)  Of course, recursive invocations each "
"have their own local namespace."
msgstr ""
"*Namespace* lokal untuk suatu fungsi dibuat ketika fungsi dipanggil, dan "
"dihapus ketika fungsi kembali *returns* atau memunculkan pengecualian yang "
"tidak ditangani dalam fungsi tersebut. (Sebenarnya, melupakan akan menjadi "
"cara yang lebih baik untuk menggambarkan apa yang sebenarnya terjadi.) Tentu"
" saja, pemanggilan rekursif masing-masing memiliki ruang-nama *namespace* "
"lokal mereka sendiri."

#: ../../tutorial/classes.rst:112
msgid ""
"A *scope* is a textual region of a Python program where a namespace is "
"directly accessible.  \"Directly accessible\" here means that an unqualified"
" reference to a name attempts to find the name in the namespace."
msgstr ""
"Suatu *scope* adalah wilayah tekstual dari program Python di mana "
"*namespace* dapat diakses secara langsung. \"Directly accessible\" di sini "
"berarti bahwa referensi yang tidak memenuhi syarat untuk suatu nama berusaha"
" menemukan nama tersebut di *namespace*."

#: ../../tutorial/classes.rst:116
msgid ""
"Although scopes are determined statically, they are used dynamically. At any"
" time during execution, there are 3 or 4 nested scopes whose namespaces are "
"directly accessible:"
msgstr ""
"Meskipun cakupan *scopes* ditentukan secara statis, mereka digunakan secara "
"dinamis. Setiap saat selama eksekusi, setidaknya ada 3 atau 4 cakupan "
"bersarang yang ruang nama-nya *namespaces* dapat diakses secara langsung:"

#: ../../tutorial/classes.rst:120
msgid "the innermost scope, which is searched first, contains the local names"
msgstr ""
"ruang lingkup *scope* terdalam, yang dicari pertama kali, berisi nama-nama "
"lokal"

#: ../../tutorial/classes.rst:121
msgid ""
"the scopes of any enclosing functions, which are searched starting with the "
"nearest enclosing scope, contains non-local, but also non-global names"
msgstr ""
"lingkup *scope* dari setiap fungsi penutup, yang dicari dimulai dengan "
"lingkup penutup terdekat, berisi nama-nama non-lokal, tetapi juga non-global"

#: ../../tutorial/classes.rst:123
msgid "the next-to-last scope contains the current module's global names"
msgstr "lingkup berikutnya *next-to-last* berisi nama global modul saat ini"

#: ../../tutorial/classes.rst:124
msgid ""
"the outermost scope (searched last) is the namespace containing built-in "
"names"
msgstr ""
"ruang lingkup *scope* terluar (dicari terakhir) adalah *namespace* yang "
"mengandung nama bawaan"

#: ../../tutorial/classes.rst:126
msgid ""
"If a name is declared global, then all references and assignments go "
"directly to the middle scope containing the module's global names.  To "
"rebind variables found outside of the innermost scope, the "
":keyword:`nonlocal` statement can be used; if not declared nonlocal, those "
"variables are read-only (an attempt to write to such a variable will simply "
"create a *new* local variable in the innermost scope, leaving the "
"identically named outer variable unchanged)."
msgstr ""
"Jika sebuah nama dinyatakan global, maka semua referensi dan penugasan "
"langsung ke lingkup *scope* tengah yang berisi nama global modul. Untuk "
"mengembalikan variabel yang ditemukan di luar cakupan terdalam, pernyataan "
":keyword:`nonlocal` dapat digunakan; jika tidak dideklarasikan nonlokal, "
"variabel-variabel itu hanya baca-saja (upaya untuk menulis ke variabel "
"seperti itu hanya akan membuat variabel lokal *baru* dalam cakupan terdalam,"
" membiarkan variabel luar yang dinamai identik tidak berubah)."

#: ../../tutorial/classes.rst:133
msgid ""
"Usually, the local scope references the local names of the (textually) "
"current function.  Outside functions, the local scope references the same "
"namespace as the global scope: the module's namespace. Class definitions "
"place yet another namespace in the local scope."
msgstr ""
"Biasanya, cakupan lokal merujuk nama lokal dari fungsi (secara tekstual) "
"saat ini. Fungsi luar, lingkup lokal merujuk *namespace* yang sama dengan "
"lingkup global: *namespace* modul. Definisi kelas menempatkan namespace lain"
" dalam lingkup lokal."

#: ../../tutorial/classes.rst:138
msgid ""
"It is important to realize that scopes are determined textually: the global "
"scope of a function defined in a module is that module's namespace, no "
"matter from where or by what alias the function is called.  On the other "
"hand, the actual search for names is done dynamically, at run time --- "
"however, the language definition is evolving towards static name resolution,"
" at \"compile\" time, so don't rely on dynamic name resolution!  (In fact, "
"local variables are already determined statically.)"
msgstr ""
"Penting untuk menyadari bahwa cakupan *scope* ditentukan secara tekstual: "
"ruang lingkup global dari suatu fungsi yang didefinisikan dalam modul adalah"
" ruang nama *namespace* modul itu, tidak peduli dari mana atau oleh apa "
"alias fungsi itu dipanggil. Di sisi lain, pencarian nama sebenarnya "
"dilakukan secara dinamis, pada saat *run time* --- namun, definisi bahasa "
"berkembang menuju resolusi nama statis, pada waktu \"compile\", jadi jangan "
"mengandalkan resolusi nama dinamis! (Faktanya, variabel lokal sudah "
"ditentukan secara statis.)"

#: ../../tutorial/classes.rst:146
msgid ""
"A special quirk of Python is that -- if no :keyword:`global` or "
":keyword:`nonlocal` statement is in effect -- assignments to names always go"
" into the innermost scope. Assignments do not copy data --- they just bind "
"names to objects.  The same is true for deletions: the statement ``del x`` "
"removes the binding of ``x`` from the namespace referenced by the local "
"scope.  In fact, all operations that introduce new names use the local "
"scope: in particular, :keyword:`import` statements and function definitions "
"bind the module or function name in the local scope."
msgstr ""
"Sebuah kekhasan khusus dari Python adalah bahwa -- jika tidak ada pernyataan"
" :keyword:`global` atau pernyataan :keyword:`nonlocal` yang berlaku -- "
"pemberian nilai untuk nama selalu masuk ke ruang lingkup terdalam. Pemberian"
" nilai tidak menyalin data --- mereka hanya mengikat nama ke objek. Hal yang"
" sama berlaku untuk penghapusan: pernyataan ``del x`` menghapus pengikatan "
"``x`` dari *namespace* yang dirujuk oleh lingkup *scope* lokal. Bahkan, "
"semua operasi yang memperkenalkan nama-nama baru menggunakan lingkup lokal: "
"khususnya, pernyataan :keyword:`import` dan definisi fungsi mengikat modul "
"atau nama fungsi di lingkup lokal."

#: ../../tutorial/classes.rst:154
msgid ""
"The :keyword:`global` statement can be used to indicate that particular "
"variables live in the global scope and should be rebound there; the "
":keyword:`nonlocal` statement indicates that particular variables live in an"
" enclosing scope and should be rebound there."
msgstr ""
"Pernyataan :keyword:`global` dapat digunakan untuk menunjukkan bahwa "
"variabel tertentu hidup dalam lingkup global dan harus kembali ke sana; "
"pernyataan :keyword:`nonlocal` menunjukkan bahwa variabel tertentu hidup "
"dalam cakupan terlampir dan harus dikembalikan ke sana."

#: ../../tutorial/classes.rst:162
msgid "Scopes and Namespaces Example"
msgstr "Contoh Lingkup *Scopes* dan Ruang Nama *Namespaces*"

#: ../../tutorial/classes.rst:164
msgid ""
"This is an example demonstrating how to reference the different scopes and "
"namespaces, and how :keyword:`global` and :keyword:`nonlocal` affect "
"variable binding::"
msgstr ""
"Ini adalah contoh yang menunjukkan cara mereferensikan lingkup *scopes* dan "
"ruang nama *namespaces* yang berbeda, dan bagaimana :keyword:`global` dan "
":keyword:`nonlocal` memengaruhi pengikatan variabel::"

#: ../../tutorial/classes.rst:191
msgid "The output of the example code is:"
msgstr "Keluaran dari contoh kode adalah:"

#: ../../tutorial/classes.rst:200
msgid ""
"Note how the *local* assignment (which is default) didn't change "
"*scope_test*\\'s binding of *spam*.  The :keyword:`nonlocal` assignment "
"changed *scope_test*\\'s binding of *spam*, and the :keyword:`global` "
"assignment changed the module-level binding."
msgstr ""
"Perhatikan bagaimana pemberian nilai *local* (yang bawaan) tidak mengubah "
"*scope_test*\\s pengikatan *spam*. Pemberian nilai :keyword:`nonlocal` "
"mengubah *scope_test*\\'s pengikatan *spam*, dan pemberian nilai "
":keyword:`global` mengubah pengikatan level modul."

#: ../../tutorial/classes.rst:205
msgid ""
"You can also see that there was no previous binding for *spam* before the "
":keyword:`global` assignment."
msgstr ""
"Anda juga dapat melihat bahwa tidak ada pengikatan sebelumnya untuk *spam* "
"sebelum pemberian nilai :keyword:`global`."

#: ../../tutorial/classes.rst:212
msgid "A First Look at Classes"
msgstr "Pandangan Pertama tentang Kelas"

#: ../../tutorial/classes.rst:214
msgid ""
"Classes introduce a little bit of new syntax, three new object types, and "
"some new semantics."
msgstr ""
"Kelas memperkenalkan sedikit sintaks baru, tiga tipe objek baru, dan "
"beberapa semantik baru."

#: ../../tutorial/classes.rst:221
msgid "Class Definition Syntax"
msgstr "Sintaks Definisi Kelas"

#: ../../tutorial/classes.rst:223
msgid "The simplest form of class definition looks like this::"
msgstr "Bentuk definisi kelas paling sederhana terlihat seperti ini::"

#: ../../tutorial/classes.rst:232
msgid ""
"Class definitions, like function definitions (:keyword:`def` statements) "
"must be executed before they have any effect.  (You could conceivably place "
"a class definition in a branch of an :keyword:`if` statement, or inside a "
"function.)"
msgstr ""
"Definisi kelas, seperti definisi fungsi (pernyataan :keyword:`def`) harus "
"dieksekusi sebelum mereka memiliki efek. (Anda dapat menempatkan definisi "
"kelas di cabang dari pernyataan :keyword:`if`, atau di dalam suatu fungsi.)"

#: ../../tutorial/classes.rst:236
msgid ""
"In practice, the statements inside a class definition will usually be "
"function definitions, but other statements are allowed, and sometimes useful"
" --- we'll come back to this later.  The function definitions inside a class"
" normally have a peculiar form of argument list, dictated by the calling "
"conventions for methods --- again, this is explained later."
msgstr ""
"Dalam praktiknya, pernyataan di dalam definisi kelas biasanya akan menjadi "
"definisi fungsi, tetapi pernyataan lain diizinkan, dan terkadang berguna ---"
" kami akan kembali ke sini nanti. Definisi fungsi di dalam kelas biasanya "
"memiliki bentuk khusus daftar argumen, didikte oleh konvensi pemanggilan "
"untuk metode --- sekali lagi, ini dijelaskan nanti."

#: ../../tutorial/classes.rst:242
msgid ""
"When a class definition is entered, a new namespace is created, and used as "
"the local scope --- thus, all assignments to local variables go into this "
"new namespace.  In particular, function definitions bind the name of the new"
" function here."
msgstr ""
"Ketika definisi kelas dimasukkan, *namespace* baru dibuat, dan digunakan "
"sebagai lingkup *scope* lokal --- dengan demikian, semua tugas untuk "
"variabel lokal masuk ke *namespace* baru ini. Secara khusus, definisi fungsi"
" mengikat nama fungsi baru di sini."

#: ../../tutorial/classes.rst:247
msgid ""
"When a class definition is left normally (via the end), a *class object* is "
"created.  This is basically a wrapper around the contents of the namespace "
"created by the class definition; we'll learn more about class objects in the"
" next section.  The original local scope (the one in effect just before the "
"class definition was entered) is reinstated, and the class object is bound "
"here to the class name given in the class definition header "
"(:class:`ClassName` in the example)."
msgstr ""
"Ketika definisi kelas dibiarkan normal (melalui akhir), *class object* "
"dibuat. Ini pada dasarnya adalah pembungkus di sekitar isi *namespace* yang "
"dibuat oleh definisi kelas; kita akan belajar lebih banyak tentang objek "
"kelas di bagian selanjutnya. Lingkup *scope* lokal asli (yang berlaku tepat "
"sebelum definisi kelas dimasukkan) diaktifkan kembali, dan objek kelas "
"terikat di sini dengan nama kelas yang diberikan dalam header definisi kelas"
" (:class:`ClassName` dalam contoh)."

#: ../../tutorial/classes.rst:259
msgid "Class Objects"
msgstr "Objek Kelas *Class Objects*"

#: ../../tutorial/classes.rst:261
msgid ""
"Class objects support two kinds of operations: attribute references and "
"instantiation."
msgstr ""
"Objek kelas mendukung dua jenis operasi: referensi atribut dan instansiasi."

#: ../../tutorial/classes.rst:264
msgid ""
"*Attribute references* use the standard syntax used for all attribute "
"references in Python: ``obj.name``.  Valid attribute names are all the names"
" that were in the class's namespace when the class object was created.  So, "
"if the class definition looked like this::"
msgstr ""
"*Attribute references* menggunakan sintaks standar yang digunakan untuk "
"semua referensi atribut dalam Python: ``obj.name``. Nama atribut yang valid "
"adalah semua nama yang ada di *namespace* kelas saat objek kelas dibuat. "
"Jadi, jika definisi kelas tampak seperti ini::"

#: ../../tutorial/classes.rst:276
msgid ""
"then ``MyClass.i`` and ``MyClass.f`` are valid attribute references, "
"returning an integer and a function object, respectively. Class attributes "
"can also be assigned to, so you can change the value of ``MyClass.i`` by "
"assignment. :attr:`__doc__` is also a valid attribute, returning the "
"docstring belonging to the class: ``\"A simple example class\"``."
msgstr ""
"kemudian ``MyClass.i`` dan ``MyClass.f`` adalah referensi atribut yang "
"valid, masing-masing mengembalikan integer dan objek fungsi. Atribut kelas "
"juga dapat ditetapkan, sehingga Anda dapat mengubah nilai ``MyClass.i`` oleh"
" penugasan. :attr:`__doc__` juga merupakan atribut yang valid, mengembalikan"
" *docstring* milik kelas: ``\"A simple example class\"``."

#: ../../tutorial/classes.rst:282
msgid ""
"Class *instantiation* uses function notation.  Just pretend that the class "
"object is a parameterless function that returns a new instance of the class."
" For example (assuming the above class)::"
msgstr ""
"*instantiation* kelas menggunakan notasi fungsi. Hanya berpura-pura bahwa "
"objek kelas adalah fungsi tanpa parameter yang mengembalikan instance baru "
"dari kelas. Misalnya (dengan asumsi kelas di atas)::"

#: ../../tutorial/classes.rst:288
msgid ""
"creates a new *instance* of the class and assigns this object to the local "
"variable ``x``."
msgstr ""
"membuat *instance* baru dari kelas dan menetapkan objek ini ke variabel "
"lokal ``x``."

#: ../../tutorial/classes.rst:291
msgid ""
"The instantiation operation (\"calling\" a class object) creates an empty "
"object. Many classes like to create objects with instances customized to a "
"specific initial state. Therefore a class may define a special method named "
":meth:`__init__`, like this::"
msgstr ""
"Operasi instansiasi (\"calling\" objek kelas) membuat objek kosong. Banyak "
"kelas suka membuat objek dengan *instance* yang disesuaikan dengan kondisi "
"awal tertentu. Oleh karena itu sebuah kelas dapat mendefinisikan metode "
"khusus bernama :meth:`__init__`, seperti ini::"

#: ../../tutorial/classes.rst:299
msgid ""
"When a class defines an :meth:`__init__` method, class instantiation "
"automatically invokes :meth:`__init__` for the newly-created class instance."
"  So in this example, a new, initialized instance can be obtained by::"
msgstr ""
"Ketika sebuah kelas mendefinisikan metode :meth:`__init__`, instantiasi "
"kelas secara otomatis memanggil :meth:`__init__` untuk instance kelas yang "
"baru dibuat. Jadi dalam contoh ini, contoh baru yang diinisialisasi dapat "
"diperoleh oleh::"

#: ../../tutorial/classes.rst:305
msgid ""
"Of course, the :meth:`__init__` method may have arguments for greater "
"flexibility.  In that case, arguments given to the class instantiation "
"operator are passed on to :meth:`__init__`.  For example, ::"
msgstr ""
"Tentu saja, metode :meth:`__init__` mungkin memiliki argumen untuk "
"fleksibilitas yang lebih besar. Dalam hal itu, argumen yang diberikan kepada"
" operator instantiasi kelas diteruskan ke :meth:`__init__`. Sebagai contoh, "
"::"

#: ../../tutorial/classes.rst:322
msgid "Instance Objects"
msgstr "Objek *Instance*"

#: ../../tutorial/classes.rst:324
msgid ""
"Now what can we do with instance objects?  The only operations understood by"
" instance objects are attribute references.  There are two kinds of valid "
"attribute names: data attributes and methods."
msgstr ""
"Sekarang apa yang bisa kita lakukan dengan objek instan? Satu-satunya "
"operasi yang dipahami oleh objek instan adalah referensi atribut. Ada dua "
"jenis nama atribut yang valid: atribut data, dan metode."

#: ../../tutorial/classes.rst:328
msgid ""
"*data attributes* correspond to \"instance variables\" in Smalltalk, and to "
"\"data members\" in C++.  Data attributes need not be declared; like local "
"variables, they spring into existence when they are first assigned to.  For "
"example, if ``x`` is the instance of :class:`MyClass` created above, the "
"following piece of code will print the value ``16``, without leaving a "
"trace::"
msgstr ""
"*data attributes* sesuai dengan \"variabel instan\" di Smalltalk, dan \"data"
" members\" di C++. Atribut data tidak perlu dinyatakan; seperti variabel "
"lokal, mereka muncul ketika mereka pertama kali ditugaskan. Misalnya, jika "
"``x`` adalah turunan dari :class:`MyClass` yang dibuat di atas, bagian kode "
"berikut akan mencetak nilai ``16``, tanpa meninggalkan jejak::"

#: ../../tutorial/classes.rst:340
msgid ""
"The other kind of instance attribute reference is a *method*. A method is a "
"function that \"belongs to\" an object.  (In Python, the term method is not "
"unique to class instances: other object types can have methods as well.  For"
" example, list objects have methods called append, insert, remove, sort, and"
" so on. However, in the following discussion, we'll use the term method "
"exclusively to mean methods of class instance objects, unless explicitly "
"stated otherwise.)"
msgstr ""
"Jenis lain dari referensi atribut instance adalah *method*. Metode adalah "
"fungsi yang \"milik\" suatu objek. (Dalam Python, istilah metode tidak unik "
"untuk instance kelas: tipe objek lain dapat memiliki metode juga. Misalnya, "
"objek daftar memiliki metode yang disebut *append*, *insert*, *remove*, "
"*sort*, dan sebagainya. Namun, dalam diskusi berikut, kita akan menggunakan "
"istilah metode secara eksklusif untuk mengartikan metode objek *instance* "
"kelas, kecuali dinyatakan secara eksplisit.)"

#: ../../tutorial/classes.rst:349
msgid ""
"Valid method names of an instance object depend on its class.  By "
"definition, all attributes of a class that are function  objects define "
"corresponding methods of its instances.  So in our example, ``x.f`` is a "
"valid method reference, since ``MyClass.f`` is a function, but ``x.i`` is "
"not, since ``MyClass.i`` is not.  But ``x.f`` is not the same thing as "
"``MyClass.f`` --- it is a *method object*, not a function object."
msgstr ""
"Nama metode yang valid dari objek *instance* bergantung pada kelasnya. "
"Menurut definisi, semua atribut dari kelas yang merupakan objek fungsi "
"menentukan metode yang sesuai dari *instance*-nya. Jadi dalam contoh kita, "
"``x.f`` adalah referensi metode yang valid, karena ``MyClass.f`` adalah "
"fungsi, tetapi ``x.i`` tidak, karena ``MyClass.i`` tidak. Tetapi ``x.f`` "
"bukan hal yang sama dengan ``MyClass.f`` --- itu adalah *method object*, "
"bukan objek fungsi."

#: ../../tutorial/classes.rst:360
msgid "Method Objects"
msgstr "Metode Objek"

#: ../../tutorial/classes.rst:362
msgid "Usually, a method is called right after it is bound::"
msgstr "Biasanya, metode dipanggil tepat setelah itu terikat::"

#: ../../tutorial/classes.rst:366
msgid ""
"In the :class:`MyClass` example, this will return the string ``'hello "
"world'``. However, it is not necessary to call a method right away: ``x.f`` "
"is a method object, and can be stored away and called at a later time.  For "
"example::"
msgstr ""
"Dalam contoh :class:`MyClass`, ini akan mengembalikan string ``'hello "
"world'``. Namun, tidak perlu memanggil metode segera: ``x.f`` adalah metode "
"objek, dan dapat disimpan dan dipanggil di lain waktu. Sebagai contoh::"

#: ../../tutorial/classes.rst:374
msgid "will continue to print ``hello world`` until the end of time."
msgstr "akan terus mencetak ``hello world`` hingga akhir waktu."

#: ../../tutorial/classes.rst:376
msgid ""
"What exactly happens when a method is called?  You may have noticed that "
"``x.f()`` was called without an argument above, even though the function "
"definition for :meth:`f` specified an argument.  What happened to the "
"argument? Surely Python raises an exception when a function that requires an"
" argument is called without any --- even if the argument isn't actually "
"used..."
msgstr ""
"Apa yang sebenarnya terjadi ketika suatu metode dipanggil? Anda mungkin "
"telah memperhatikan bahwa ``x.f()`` dipanggil tanpa argumen di atas, "
"meskipun definisi fungsi untuk :meth:`f` menentukan argumen. Apa yang "
"terjadi dengan argumen itu? Tentunya Python memunculkan pengecualian ketika "
"fungsi yang membutuhkan argumen dipanggil tanpa --- bahkan jika argumen "
"tersebut tidak benar-benar digunakan..."

#: ../../tutorial/classes.rst:382
msgid ""
"Actually, you may have guessed the answer: the special thing about methods "
"is that the instance object is passed as the first argument of the function."
"  In our example, the call ``x.f()`` is exactly equivalent to "
"``MyClass.f(x)``.  In general, calling a method with a list of *n* arguments"
" is equivalent to calling the corresponding function with an argument list "
"that is created by inserting the method's instance object before the first "
"argument."
msgstr ""
"Sebenarnya, Anda mungkin sudah menebak jawabannya: hal khusus tentang metode"
" adalah objek *instance* dilewatkan sebagai argumen pertama dari fungsi. "
"Dalam contoh kita, panggilan ``x.f()`` persis sama dengan ``MyClass.f(x)``. "
"Secara umum, memanggil metode dengan daftar argumen *n* setara dengan "
"memanggil fungsi yang sesuai dengan daftar argumen yang dibuat dengan "
"menyisipkan objek contoh metode sebelum argumen pertama."

#: ../../tutorial/classes.rst:389
msgid ""
"If you still don't understand how methods work, a look at the implementation"
" can perhaps clarify matters.  When a non-data attribute of an instance is "
"referenced, the instance's class is searched.  If the name denotes a valid "
"class attribute that is a function object, a method object is created by "
"packing (pointers to) the instance object and the function object just found"
" together in an abstract object: this is the method object.  When the method"
" object is called with an argument list, a new argument list is constructed "
"from the instance object and the argument list, and the function object is "
"called with this new argument list."
msgstr ""
"Jika Anda masih tidak mengerti bagaimana metode bekerja, melihat "
"implementasi mungkin dapat mengklarifikasi masalah. Ketika atribut non-data "
"dari sebuah *instance* direferensikan, kelas *instance* tersebut dicari. "
"Jika nama menunjukkan atribut kelas yang valid yang merupakan objek fungsi, "
"objek metode dibuat dengan mengemas (menunjuk *pointers* ke) objek "
"*instance* dan objek fungsi yang baru saja ditemukan bersama dalam objek "
"abstrak: ini adalah objek metode. Ketika objek metode dipanggil dengan "
"daftar argumen, daftar argumen baru dibangun dari objek instance dan daftar "
"argumen, dan objek fungsi dipanggil dengan daftar argumen baru ini."

#: ../../tutorial/classes.rst:403
msgid "Class and Instance Variables"
msgstr "Variabel Kelas dan *Instance*"

#: ../../tutorial/classes.rst:405
msgid ""
"Generally speaking, instance variables are for data unique to each instance "
"and class variables are for attributes and methods shared by all instances "
"of the class::"
msgstr ""
"Secara umum, variabel *instance* adalah untuk data unik untuk setiap "
"*instance* dan variabel kelas adalah untuk atribut dan metode yang dibagikan"
" oleh semua *instance* kelas::"

#: ../../tutorial/classes.rst:427
msgid ""
"As discussed in :ref:`tut-object`, shared data can have possibly surprising "
"effects with involving :term:`mutable` objects such as lists and "
"dictionaries. For example, the *tricks* list in the following code should "
"not be used as a class variable because just a single list would be shared "
"by all *Dog* instances::"
msgstr ""
"Seperti yang dibahas dalam :ref:`tut-object`, data bersama dapat memiliki "
"efek yang mengejutkan dengan melibatkan objek :term:`mutable` seperti daftar"
" *lists* dan kamus *dictionaries*. Sebagai contoh, daftar *tricks* dalam "
"kode berikut tidak boleh digunakan sebagai variabel kelas karena hanya satu "
"daftar yang akan dibagikan oleh semua *Dog* instance::"

#: ../../tutorial/classes.rst:450
msgid "Correct design of the class should use an instance variable instead::"
msgstr ""
"Desain kelas yang benar harus menggunakan variabel *instance* sebagai "
"gantinya::"

#: ../../tutorial/classes.rst:474
msgid "Random Remarks"
msgstr "Keterangan Acak"

#: ../../tutorial/classes.rst:478
msgid ""
"If the same attribute name occurs in both an instance and in a class, then "
"attribute lookup prioritizes the instance::"
msgstr ""
"Jika nama atribut yang sama muncul di kedua *instance* dan di kelas, maka "
"pencarian atribut memprioritaskan *instance*::"

#: ../../tutorial/classes.rst:493
msgid ""
"Data attributes may be referenced by methods as well as by ordinary users "
"(\"clients\") of an object.  In other words, classes are not usable to "
"implement pure abstract data types.  In fact, nothing in Python makes it "
"possible to enforce data hiding --- it is all based upon convention.  (On "
"the other hand, the Python implementation, written in C, can completely hide"
" implementation details and control access to an object if necessary; this "
"can be used by extensions to Python written in C.)"
msgstr ""
"Atribut data dapat dirujuk oleh metode dan juga oleh pengguna biasa "
"(\"clients\") dari suatu objek. Dengan kata lain, kelas tidak dapat "
"digunakan untuk mengimplementasikan tipe data abstrak murni. Faktanya, tidak"
" ada dalam Python yang memungkinkan untuk menegakkan *enforce* data yang "
"disembunyikan --- semuanya didasarkan pada konvensi. (Di sisi lain, "
"implementasi Python, ditulis dalam C, dapat sepenuhnya menyembunyikan detail"
" implementasi dan mengontrol akses ke objek jika perlu; ini dapat digunakan "
"oleh ekstensi ke Python yang ditulis dalam C.)"

#: ../../tutorial/classes.rst:501
msgid ""
"Clients should use data attributes with care --- clients may mess up "
"invariants maintained by the methods by stamping on their data attributes.  "
"Note that clients may add data attributes of their own to an instance object"
" without affecting the validity of the methods, as long as name conflicts "
"are avoided --- again, a naming convention can save a lot of headaches here."
msgstr ""
"Klien harus menggunakan atribut data dengan hati-hati --- klien dapat "
"mengacaukan invarian yang dikelola oleh metode dengan menginjak *stamping* "
"atribut data mereka. Perhatikan bahwa klien dapat menambahkan atribut data "
"mereka sendiri ke objek *instance* tanpa memengaruhi validitas metode, "
"asalkan konflik nama dihindari --- sekali lagi, konvensi penamaan dapat "
"menghindarkan dari banyak sakit kepala di sini."

#: ../../tutorial/classes.rst:507
msgid ""
"There is no shorthand for referencing data attributes (or other methods!) "
"from within methods.  I find that this actually increases the readability of"
" methods: there is no chance of confusing local variables and instance "
"variables when glancing through a method."
msgstr ""
"Tidak ada istilah untuk referensi atribut data (atau metode lain!) dari "
"dalam metode. Saya menemukan bahwa ini sebenarnya meningkatkan keterbacaan "
"metode: tidak ada kemungkinan membingungkan variabel lokal dan variabel "
"*instance* ketika melirik *glancing* melalui metode."

#: ../../tutorial/classes.rst:512
msgid ""
"Often, the first argument of a method is called ``self``.  This is nothing "
"more than a convention: the name ``self`` has absolutely no special meaning "
"to Python.  Note, however, that by not following the convention your code "
"may be less readable to other Python programmers, and it is also conceivable"
" that a *class browser* program might be written that relies upon such a "
"convention."
msgstr ""
"Seringkali, argumen pertama dari suatu metode disebut ``self``. Ini tidak "
"lebih dari sebuah konvensi: nama ``self`` sama sekali tidak memiliki arti "
"khusus untuk Python. Perhatikan, bagaimanapun, bahwa dengan tidak mengikuti "
"konvensi kode Anda mungkin kurang dapat dibaca oleh programmer Python lain, "
"dan juga dapat dibayangkan bahwa program *class browser* dapat ditulis yang "
"bergantung pada konvensi semacam itu."

#: ../../tutorial/classes.rst:518
msgid ""
"Any function object that is a class attribute defines a method for instances"
" of that class.  It is not necessary that the function definition is "
"textually enclosed in the class definition: assigning a function object to a"
" local variable in the class is also ok.  For example::"
msgstr ""
"Objek fungsi apa pun yang merupakan atribut kelas menentukan metode untuk "
"*instance* dari kelas itu. Tidak perlu bahwa definisi fungsi tertutup secara"
" teks dalam definisi kelas: menetapkan objek fungsi ke variabel lokal di "
"kelas juga ok. Sebagai contoh::"

#: ../../tutorial/classes.rst:535
msgid ""
"Now ``f``, ``g`` and ``h`` are all attributes of class :class:`C` that refer"
" to function objects, and consequently they are all methods of instances of "
":class:`C` --- ``h`` being exactly equivalent to ``g``.  Note that this "
"practice usually only serves to confuse the reader of a program."
msgstr ""
"Sekarang ``f``, ``g`` dan ``h`` adalah semua atribut class :class:`C` yang "
"merujuk ke objek-objek fungsi, dan akibatnya semuanya adalah metode instance"
" dari :class:`C` --- ``h`` sama persis dengan ``g``. Perhatikan bahwa "
"praktik ini biasanya hanya membingungkan pembaca program."

#: ../../tutorial/classes.rst:540
msgid ""
"Methods may call other methods by using method attributes of the ``self`` "
"argument::"
msgstr ""
"Metode dapat memanggil metode lain dengan menggunakan atribut metode dari "
"argumen ``self``::"

#: ../../tutorial/classes.rst:554
msgid ""
"Methods may reference global names in the same way as ordinary functions.  "
"The global scope associated with a method is the module containing its "
"definition.  (A class is never used as a global scope.)  While one rarely "
"encounters a good reason for using global data in a method, there are many "
"legitimate uses of the global scope: for one thing, functions and modules "
"imported into the global scope can be used by methods, as well as functions "
"and classes defined in it.  Usually, the class containing the method is "
"itself defined in this global scope, and in the next section we'll find some"
" good reasons why a method would want to reference its own class."
msgstr ""
"Metode dapat merujuk nama global dengan cara yang sama seperti fungsi biasa."
" Ruang lingkup *scope* global yang terkait dengan suatu metode adalah modul "
"yang berisi definisinya. (Kelas tidak pernah digunakan sebagai ruang lingkup"
" *scope* global.) Sementara seseorang jarang menemukan alasan yang baik "
"untuk menggunakan data global dalam suatu metode, ada banyak penggunaan sah "
"lingkup global: untuk satu hal, fungsi dan modul yang diimpor ke dalam "
"lingkup global dapat digunakan oleh metode, serta fungsi dan kelas yang "
"didefinisikan di dalamnya. Biasanya, kelas yang berisi metode itu sendiri "
"didefinisikan dalam lingkup global ini, dan di bagian selanjutnya kita akan "
"menemukan beberapa alasan bagus mengapa suatu metode ingin merujuk kelasnya "
"sendiri."

#: ../../tutorial/classes.rst:564
msgid ""
"Each value is an object, and therefore has a *class* (also called its "
"*type*). It is stored as ``object.__class__``."
msgstr ""
"Setiap nilai adalah objek, dan karenanya memiliki *kelas* (juga disebut "
"sebagai *type*). Ini disimpan sebagai ``object.__class__``."

#: ../../tutorial/classes.rst:571
msgid "Inheritance"
msgstr "Pewarisan"

#: ../../tutorial/classes.rst:573
msgid ""
"Of course, a language feature would not be worthy of the name \"class\" "
"without supporting inheritance.  The syntax for a derived class definition "
"looks like this::"
msgstr ""
"Tentu saja, fitur bahasa tidak akan layak untuk nama \"class\" tanpa "
"mendukung pewarisan. Sintaks untuk definisi kelas turunan terlihat seperti "
"ini::"

#: ../../tutorial/classes.rst:584
msgid ""
"The name :class:`BaseClassName` must be defined in a scope containing the "
"derived class definition.  In place of a base class name, other arbitrary "
"expressions are also allowed.  This can be useful, for example, when the "
"base class is defined in another module::"
msgstr ""
"Nama :class:`BaseClassName` harus didefinisikan dalam lingkup yang berisi "
"definisi kelas turunan. Di tempat nama kelas dasar, ekspresi berubah-ubah "
"*arbitrary* lainnya juga diperbolehkan. Ini bisa berguna, misalnya, ketika "
"kelas dasar didefinisikan dalam modul lain::"

#: ../../tutorial/classes.rst:591
msgid ""
"Execution of a derived class definition proceeds the same as for a base "
"class. When the class object is constructed, the base class is remembered.  "
"This is used for resolving attribute references: if a requested attribute is"
" not found in the class, the search proceeds to look in the base class.  "
"This rule is applied recursively if the base class itself is derived from "
"some other class."
msgstr ""
"Eksekusi definisi kelas turunan menghasilkan sama seperti untuk kelas dasar."
" Ketika objek kelas dibangun, kelas dasar diingat. Ini digunakan untuk "
"menyelesaikan referensi atribut: jika atribut yang diminta tidak ditemukan "
"di kelas, pencarian dilanjutkan untuk mencari di kelas dasar. Aturan ini "
"diterapkan secara rekursif jika kelas dasar itu sendiri berasal dari "
"beberapa kelas lain."

#: ../../tutorial/classes.rst:597
msgid ""
"There's nothing special about instantiation of derived classes: "
"``DerivedClassName()`` creates a new instance of the class.  Method "
"references are resolved as follows: the corresponding class attribute is "
"searched, descending down the chain of base classes if necessary, and the "
"method reference is valid if this yields a function object."
msgstr ""
"Tidak ada yang istimewa tentang instance kelas turunan: "
"``DerivedClassName()`` membuat instance baru dari kelas. Referensi metode "
"diselesaikan sebagai berikut: atribut kelas yang sesuai dicari, turun rantai"
" kelas dasar jika perlu, dan referensi metode ini valid jika ini "
"menghasilkan objek fungsi."

#: ../../tutorial/classes.rst:603
msgid ""
"Derived classes may override methods of their base classes.  Because methods"
" have no special privileges when calling other methods of the same object, a"
" method of a base class that calls another method defined in the same base "
"class may end up calling a method of a derived class that overrides it.  "
"(For C++ programmers: all methods in Python are effectively ``virtual``.)"
msgstr ""
"Kelas turunan dapat menimpa metode kelas dasar mereka. Karena metode tidak "
"memiliki hak khusus ketika memanggil metode lain dari objek yang sama, "
"metode kelas dasar yang memanggil metode lain yang didefinisikan dalam kelas"
" dasar yang sama mungkin akhirnya memanggil metode kelas turunan yang "
"menimpanya. (Untuk programmer C++: semua metode dalam Python secara efektif "
"``virtual``.)"

#: ../../tutorial/classes.rst:609
msgid ""
"An overriding method in a derived class may in fact want to extend rather "
"than simply replace the base class method of the same name. There is a "
"simple way to call the base class method directly: just call "
"``BaseClassName.methodname(self, arguments)``.  This is occasionally useful "
"to clients as well.  (Note that this only works if the base class is "
"accessible as ``BaseClassName`` in the global scope.)"
msgstr ""
"Menimpa metode dalam kelas turunan mungkin sebenarnya ingin memperluas "
"daripada hanya mengganti metode kelas dasar dengan nama yang sama. Ada cara "
"sederhana untuk memanggil metode kelas dasar secara langsung: cukup panggil "
"``BaseClassName.methodname(self, arguments)``. Ini kadang-kadang berguna "
"untuk klien juga. (Perhatikan bahwa ini hanya berfungsi jika kelas dasar "
"dapat diakses sebagai ``BaseClassName`` dalam lingkup global.)"

#: ../../tutorial/classes.rst:616
msgid "Python has two built-in functions that work with inheritance:"
msgstr "Python memiliki dua fungsi bawaan yang bekerja dengan warisan:"

#: ../../tutorial/classes.rst:618
msgid ""
"Use :func:`isinstance` to check an instance's type: ``isinstance(obj, int)``"
" will be ``True`` only if ``obj.__class__`` is :class:`int` or some class "
"derived from :class:`int`."
msgstr ""
"Gunakan :func:`isinstance` untuk memeriksa jenis instance: ``isinstance(obj,"
" int)`` akan menjadi ``True`` hanya jika ``obj.__class__`` adalah "
":class:`int` atau beberapa kelas yang diturunkan dari :class:`int`."

#: ../../tutorial/classes.rst:622
msgid ""
"Use :func:`issubclass` to check class inheritance: ``issubclass(bool, int)``"
" is ``True`` since :class:`bool` is a subclass of :class:`int`.  However, "
"``issubclass(float, int)`` is ``False`` since :class:`float` is not a "
"subclass of :class:`int`."
msgstr ""
"Gunakan :func:`issubclass` untuk memeriksa warisan kelas: ``issubclass(bool,"
" int)``adalah ``True`` karena :class:`bool` adalah subkelas dari "
":class:`int`. Namun, ``issubclass(float, int)`` adalah ``False`` karena "
":class:`float` bukan subkelas dari :class:`int`."

#: ../../tutorial/classes.rst:632
msgid "Multiple Inheritance"
msgstr "Pewarisan Berganda"

#: ../../tutorial/classes.rst:634
msgid ""
"Python supports a form of multiple inheritance as well.  A class definition "
"with multiple base classes looks like this::"
msgstr ""
"Python mendukung bentuk pewarisan berganda juga. Definisi kelas dengan "
"beberapa kelas dasar terlihat seperti ini::"

#: ../../tutorial/classes.rst:644
msgid ""
"For most purposes, in the simplest cases, you can think of the search for "
"attributes inherited from a parent class as depth-first, left-to-right, not "
"searching twice in the same class where there is an overlap in the "
"hierarchy. Thus, if an attribute is not found in :class:`DerivedClassName`, "
"it is searched for in :class:`Base1`, then (recursively) in the base classes"
" of :class:`Base1`, and if it was not found there, it was searched for in "
":class:`Base2`, and so on."
msgstr ""
"Untuk sebagian besar tujuan, dalam kasus paling sederhana, Anda dapat "
"menganggap pencarian atribut yang diwarisi dari kelas induk sebagai "
"kedalaman-pertama *depth-first*, kiri-ke-kanan, bukan mencari dua kali di "
"kelas yang sama di mana ada tumpang tindih dalam hierarki. Dengan demikian, "
"jika atribut tidak ditemukan di :class:`DerivedClassName`, itu dicari di "
":class:`Base1`, kemudian (secara rekursif) di kelas dasar dari "
":class:`Base1`, dan jika tidak ditemukan di sana, itu dicari di "
":class:`Base2`, dan seterusnya."

#: ../../tutorial/classes.rst:651
msgid ""
"In fact, it is slightly more complex than that; the method resolution order "
"changes dynamically to support cooperative calls to :func:`super`.  This "
"approach is known in some other multiple-inheritance languages as call-next-"
"method and is more powerful than the super call found in single-inheritance "
"languages."
msgstr ""
"Faktanya, ini sedikit lebih kompleks dari itu; urutan resolusi metode "
"berubah secara dinamis untuk mendukung pemanggilan kooperatif ke "
":func:`super`. Pendekatan ini dikenal dalam beberapa bahasa warisan ganda "
"sebagai metode panggilan-berikutnya *call-next-method* dan lebih berdaya "
"daripada panggilan super yang ditemukan dalam bahasa warisan tunggal."

#: ../../tutorial/classes.rst:657
msgid ""
"Dynamic ordering is necessary because all cases of multiple inheritance "
"exhibit one or more diamond relationships (where at least one of the parent "
"classes can be accessed through multiple paths from the bottommost class).  "
"For example, all classes inherit from :class:`object`, so any case of "
"multiple inheritance provides more than one path to reach :class:`object`.  "
"To keep the base classes from being accessed more than once, the dynamic "
"algorithm linearizes the search order in a way that preserves the left-to-"
"right ordering specified in each class, that calls each parent only once, "
"and that is monotonic (meaning that a class can be subclassed without "
"affecting the precedence order of its parents). Taken together, these "
"properties make it possible to design reliable and extensible classes with "
"multiple inheritance.  For more detail, see "
"https://www.python.org/download/releases/2.3/mro/."
msgstr ""
"Urutan dinamis diperlukan karena semua kasus pewarisan berganda menunjukkan "
"satu atau lebih hubungan intan *diamond relationships* (di mana setidaknya "
"satu dari kelas induk dapat diakses melalui beberapa jalur dari kelas "
"bawah). Sebagai contoh, semua kelas mewarisi dari :class:`object`, jadi "
"segala kasus pewarisan berganda menyediakan lebih dari satu jalur untuk "
"mencapai :class:` object`. Untuk menjaga agar kelas dasar tidak diakses "
"lebih dari sekali, algoritma dinamis linier mengurutkan urutan pencarian "
"dengan cara yang mempertahankan urutan kiri-ke-kanan yang ditentukan dalam "
"setiap kelas, yang memanggil setiap induk hanya sekali, dan itu monoton "
"(artinya suatu kelas dapat di-subklas-kan tanpa memengaruhi urutan prioritas"
" orang tuanya). Secara bersama-sama, properti ini memungkinkan untuk "
"merancang kelas yang andal dan dapat diperluas dengan banyak pewarisan. "
"Untuk detail lebih lanjut, lihat "
"https://www.python.org/download/releases/2.3/mro/."

#: ../../tutorial/classes.rst:674
msgid "Private Variables"
msgstr "Variabel Privat"

#: ../../tutorial/classes.rst:676
msgid ""
"\"Private\" instance variables that cannot be accessed except from inside an"
" object don't exist in Python.  However, there is a convention that is "
"followed by most Python code: a name prefixed with an underscore (e.g. "
"``_spam``) should be treated as a non-public part of the API (whether it is "
"a function, a method or a data member).  It should be considered an "
"implementation detail and subject to change without notice."
msgstr ""
"Variabel instance \"Private\" yang tidak dapat diakses kecuali dari dalam "
"suatu objek tidak ada dalam Python. Namun, ada konvensi yang diikuti oleh "
"sebagian besar kode Python: nama diawali dengan garis bawah (mis. ``_spam``)"
" harus diperlakukan sebagai bagian non-publik dari API (apakah itu fungsi, "
"metode atau anggota data). Ini harus dianggap sebagai detail implementasi "
"dan dapat berubah tanpa pemberitahuan."

#: ../../tutorial/classes.rst:686
msgid ""
"Since there is a valid use-case for class-private members (namely to avoid "
"name clashes of names with names defined by subclasses), there is limited "
"support for such a mechanism, called :dfn:`name mangling`.  Any identifier "
"of the form ``__spam`` (at least two leading underscores, at most one "
"trailing underscore) is textually replaced with ``_classname__spam``, where "
"``classname`` is the current class name with leading underscore(s) stripped."
"  This mangling is done without regard to the syntactic position of the "
"identifier, as long as it occurs within the definition of a class."
msgstr ""
"Karena ada kasus penggunaan yang valid untuk anggota kelas-pribadi (yaitu "
"untuk menghindari bentrokan nama dengan nama yang ditentukan oleh subkelas),"
" ada dukungan terbatas untuk mekanisme semacam itu, yang disebut :dfn:`name "
"mangling`. Setiap pengidentifikasi dari bentuk ``__spam`` (setidaknya dua "
"garis bawah utama, paling banyak satu garis bawah garis bawah) secara teks "
"diganti dengan ``_classname__spam``, di mana ``classname`` adalah nama kelas"
" saat ini dengan garis(-garis) bawah utama dilucuti. *Mangling* ini "
"dilakukan tanpa memperhatikan posisi sintaksis pengidentifikasi, asalkan "
"terjadi dalam definisi kelas."

#: ../../tutorial/classes.rst:695
msgid ""
"Name mangling is helpful for letting subclasses override methods without "
"breaking intraclass method calls.  For example::"
msgstr ""
"*Name mangling* sangat membantu untuk membiarkan subclass menimpa metode "
"tanpa memutus panggilan metode *intraclass*. Sebagai contoh::"

#: ../../tutorial/classes.rst:717
msgid ""
"The above example would work even if ``MappingSubclass`` were to introduce a"
" ``__update`` identifier since it is replaced with ``_Mapping__update`` in "
"the ``Mapping`` class  and ``_MappingSubclass__update`` in the "
"``MappingSubclass`` class respectively."
msgstr ""
"Contoh di atas akan berfungsi bahkan jika ``MappingSubclass`` akan "
"memperkenalkan sebuah pengidentifikasi ``__update`` karena diganti dengan "
"``_Mapping__update`` di kelas ``Mapping`` dan ``_MappingSubclass__update`` "
"di kelas ``MappingSubclass`` masing-masing."

#: ../../tutorial/classes.rst:722
msgid ""
"Note that the mangling rules are designed mostly to avoid accidents; it "
"still is possible to access or modify a variable that is considered private."
"  This can even be useful in special circumstances, such as in the debugger."
msgstr ""
"Perhatikan bahwa aturan *mangling* sebagian besar dirancang untuk "
"menghindari kecelakaan; masih dimungkinkan untuk mengakses atau memodifikasi"
" variabel yang dianggap pribadi. Ini bahkan dapat berguna dalam keadaan "
"khusus, seperti di *debugger*."

#: ../../tutorial/classes.rst:726
msgid ""
"Notice that code passed to ``exec()`` or ``eval()`` does not consider the "
"classname of the invoking class to be the current class; this is similar to "
"the effect of the ``global`` statement, the effect of which is likewise "
"restricted to code that is byte-compiled together.  The same restriction "
"applies to ``getattr()``, ``setattr()`` and ``delattr()``, as well as when "
"referencing ``__dict__`` directly."
msgstr ""
"Perhatikan bahwa kode yang dilewatkan ke ``exec()`` atau ``eval()`` tidak "
"menganggap nama kelas *classname* dari kelas yang dipanggil sebagai kelas "
"saat ini; ini mirip dengan efek pernyataan ``global``, yang efeknya juga "
"terbatas pada kode yang dikompilasi-byte *byte-compiled* bersama. Pembatasan"
" yang sama berlaku untuk ``getattr()``, ``setattr()`` dan ``delattr()``, "
"serta saat mereferensikan ``__dict__`` secara langsung."

#: ../../tutorial/classes.rst:737
msgid "Odds and Ends"
msgstr "Barang Sisa *Odds and Ends*"

#: ../../tutorial/classes.rst:739
msgid ""
"Sometimes it is useful to have a data type similar to the Pascal \"record\" "
"or C \"struct\", bundling together a few named data items.  An empty class "
"definition will do nicely::"
msgstr ""
"Kadang-kadang berguna untuk memiliki tipe data yang mirip dengan \"record\" "
"Pascal atau \"struct\" C, menyatukan beberapa item data bernama. Definisi "
"kelas kosong akan menghasilkan hal tersebut dengan baik::"

#: ../../tutorial/classes.rst:753
msgid ""
"A piece of Python code that expects a particular abstract data type can "
"often be passed a class that emulates the methods of that data type instead."
"  For instance, if you have a function that formats some data from a file "
"object, you can define a class with methods :meth:`read` and "
":meth:`!readline` that get the data from a string buffer instead, and pass "
"it as an argument."
msgstr ""
"Sepotong kode Python yang mengharapkan tipe data abstrak tertentu sering "
"dapat dilewatkan kelas yang mengemulasi metode tipe data itu sebagai "
"gantinya. Misalnya, jika Anda memiliki fungsi yang memformat beberapa data "
"dari objek file, Anda dapat mendefinisikan kelas dengan metode :meth:`read` "
"dan :meth:`!readline` yang mendapatkan data dari buffer string sebagai "
"gantinya, dan meneruskan itu sebagai argumen."

#: ../../tutorial/classes.rst:764
msgid ""
"Instance method objects have attributes, too: ``m.__self__`` is the instance"
" object with the method :meth:`m`, and ``m.__func__`` is the function object"
" corresponding to the method."
msgstr ""
"Objek metode *instance* memiliki atribut, juga: ``m.__self__`` adalah objek "
"instan dengan metode :meth:`m`, dan ``m.__func__`` adalah objek fungsi yang "
"sesuai dengan metode tersebut."

#: ../../tutorial/classes.rst:772
msgid "Iterators"
msgstr "*Iterators*"

#: ../../tutorial/classes.rst:774
msgid ""
"By now you have probably noticed that most container objects can be looped "
"over using a :keyword:`for` statement::"
msgstr ""
"Sekarang Anda mungkin telah memperhatikan bahwa sebagian besar objek "
"penampung *container* dapat dibuat perulangan menggunakan pernyataan "
":keyword:`for`::"

#: ../../tutorial/classes.rst:788
msgid ""
"This style of access is clear, concise, and convenient.  The use of "
"iterators pervades and unifies Python.  Behind the scenes, the "
":keyword:`for` statement calls :func:`iter` on the container object.  The "
"function returns an iterator object that defines the method "
":meth:`~iterator.__next__` which accesses elements in the container one at a"
" time.  When there are no more elements, :meth:`~iterator.__next__` raises a"
" :exc:`StopIteration` exception which tells the :keyword:`!for` loop to "
"terminate.  You can call the :meth:`~iterator.__next__` method using the "
":func:`next` built-in function; this example shows how it all works::"
msgstr ""
"Gaya akses ini jelas, ringkas, dan nyaman. Penggunaan *iterator* meliputi "
"*pervades* dan menyatukan Python. Di belakang layar, pernyataan "
":keyword:`for` memanggil :func:`iter` pada objek penampung *container*. "
"Fungsi mengembalikan objek *iterator* yang mendefinisikan metode "
":meth:`~iterator.__next__` yang mengakses elemen dalam penampung *container*"
" satu per satu. Ketika tidak ada lagi elemen, :meth:`~iterator.__next__` "
"memunculkan pengecualian :exc:`StopIteration` yang memberi tahu perulangan "
":keyword:`!for` untuk mengakhiri. Anda dapat memanggil metode "
":meth:`~iterator.__next__` menggunakan :func:`next` fungsi bawaan; contoh "
"ini menunjukkan cara kerjanya::"

#: ../../tutorial/classes.rst:813
msgid ""
"Having seen the mechanics behind the iterator protocol, it is easy to add "
"iterator behavior to your classes.  Define an :meth:`__iter__` method which "
"returns an object with a :meth:`~iterator.__next__` method.  If the class "
"defines :meth:`__next__`, then :meth:`__iter__` can just return ``self``::"
msgstr ""
"Setelah melihat mekanisme di balik protokol *iterator*, mudah untuk "
"menambahkan perilaku *iterator* ke kelas Anda. Definisikan metode "
":meth:`__iter__` yang mengembalikan objek dengan metode "
":meth:`~iterator.__next__`. Jika kelas mendefinisikan :meth:`__next__`, maka"
" :meth:`__iter__` bisa langsung mengembalikan ``self``::"

#: ../../tutorial/classes.rst:850
msgid "Generators"
msgstr "Pembangkit *Generator*"

#: ../../tutorial/classes.rst:852
msgid ""
":term:`Generators <generator>` are a simple and powerful tool for creating "
"iterators.  They are written like regular functions but use the "
":keyword:`yield` statement whenever they want to return data.  Each time "
":func:`next` is called on it, the generator resumes where it left off (it "
"remembers all the data values and which statement was last executed).  An "
"example shows that generators can be trivially easy to create::"
msgstr ""
":term:`Generators<generator>` adalah sebuah tool yang sederhana dan simpel "
"untuk membuat sebuah iterasi. Itu ditulis seperti fungsi biasa tapi "
"menggunakan pernyataan :keyword:`yield`  setiap kali ingin mengembalikan "
"sebuah data. Tiap kali :func:`next` itu dipanggil, generators tersebut akan "
"melanjutkan di mana hal itu berhenti (itu akan mengingat semua nilai dan "
"pernyataan mana yang terakhir dieksekusi). Sebuah contoh menunjukkan bahwa "
"generator sangat mudah dibuat::"

#: ../../tutorial/classes.rst:873
msgid ""
"Anything that can be done with generators can also be done with class-based "
"iterators as described in the previous section.  What makes generators so "
"compact is that the :meth:`__iter__` and :meth:`~generator.__next__` methods"
" are created automatically."
msgstr ""
"Apa pun yang dapat dilakukan dengan pembangkit *generator* juga dapat "
"dilakukan dengan *iterator* berbasis kelas seperti yang dijelaskan pada "
"bagian sebelumnya. Apa yang membuat pembangkit *generator* sangat kompak "
"adalah bahwa metode :meth:`__iter__` dan :meth:`~generator.__next__` dibuat "
"secara otomatis."

#: ../../tutorial/classes.rst:878
msgid ""
"Another key feature is that the local variables and execution state are "
"automatically saved between calls.  This made the function easier to write "
"and much more clear than an approach using instance variables like "
"``self.index`` and ``self.data``."
msgstr ""
"Fitur utama lainnya adalah variabel lokal dan status eksekusi secara "
"otomatis disimpan di antara pemanggilan. Ini membuat fungsi lebih mudah "
"untuk ditulis dan jauh lebih jelas daripada pendekatan menggunakan variabel "
"instan seperti ``self.index`` dan ``self.data``."

#: ../../tutorial/classes.rst:883
msgid ""
"In addition to automatic method creation and saving program state, when "
"generators terminate, they automatically raise :exc:`StopIteration`. In "
"combination, these features make it easy to create iterators with no more "
"effort than writing a regular function."
msgstr ""
"Selain pembuatan metode otomatis dan menyimpan status program, ketika "
"pembangkit *generator* berhenti, mereka secara otomatis menimbulkan "
":exc:`StopIteration`. Secara kombinasi, fitur-fitur ini membuatnya mudah "
"untuk membuat *iterator* tanpa lebih dari sekadar menulis fungsi biasa."

#: ../../tutorial/classes.rst:892
msgid "Generator Expressions"
msgstr "Ekspresi Pembangkit *Generator*"

#: ../../tutorial/classes.rst:894
msgid ""
"Some simple generators can be coded succinctly as expressions using a syntax"
" similar to list comprehensions but with parentheses instead of square "
"brackets. These expressions are designed for situations where the generator "
"is used right away by an enclosing function.  Generator expressions are more"
" compact but less versatile than full generator definitions and tend to be "
"more memory friendly than equivalent list comprehensions."
msgstr ""
"Beberapa pembangkit *generators* sederhana dapat dikodekan secara ringkas "
"sebagai ekspresi menggunakan sintaksis yang mirip dengan pemahaman daftar "
"*list comprehensions* tetapi dengan tanda kurung bukan dengan tanda kurung "
"siku. Ungkapan-ungkapan ini dirancang untuk situasi di mana *generator* "
"digunakan segera oleh fungsi penutup. Ekspresi *generator* lebih kompak "
"tetapi kurang fleksibel daripada definisi *generator* penuh dan cenderung "
"lebih ramah memori daripada pemahaman daftar *list comprehensions* setara."

#: ../../tutorial/classes.rst:901
msgid "Examples::"
msgstr "Contoh::"

#: ../../tutorial/classes.rst:922
msgid "Footnotes"
msgstr "Catatan kaki"

#: ../../tutorial/classes.rst:923
msgid ""
"Except for one thing.  Module objects have a secret read-only attribute "
"called :attr:`~object.__dict__` which returns the dictionary used to "
"implement the module's namespace; the name :attr:`~object.__dict__` is an "
"attribute but not a global name. Obviously, using this violates the "
"abstraction of namespace implementation, and should be restricted to things "
"like post-mortem debuggers."
msgstr ""
"Kecuali satu hal. Objek modul memiliki atribut baca-saja *read-only* rahasia"
" bernama :attr:`~object.__dict__` yang mengembalikan kamus *dictionary* yang"
" digunakan untuk mengimplementasikan *namespace* modul; nama "
":attr:`~object.__ dict__` adalah atribut tetapi bukan nama global. Jelas, "
"menggunakan ini melanggar abstraksi implementasi *namespace*, dan harus "
"dibatasi untuk hal-hal seperti *debuggers* *post-mortem*."
